package identity

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new identity API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for identity API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
AddUserToGroup adds user to group

Adds the specified user to the specified group and returns a `UserGroupMembership` object with its own OCID.

After you send your request, the new object's `lifecycleState` will temporarily be CREATING. Before using the
object, first make sure its `lifecycleState` has changed to ACTIVE.

*/
func (a *Client) AddUserToGroup(params *AddUserToGroupParams) (*AddUserToGroupOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddUserToGroupParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AddUserToGroup",
		Method:             "POST",
		PathPattern:        "/userGroupMemberships/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AddUserToGroupReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*AddUserToGroupOK), nil

}

/*
CreateCompartment creates compartment

Creates a new compartment in your tenancy.

**Important:** Compartments cannot be renamed or deleted.

You must specify your tenancy's OCID as the compartment ID in the request object. Remember that the tenancy
is simply the root compartment. For information about OCIDs, see
[Resource Identifiers](/Content/General/Concepts/identifiers.htm).

You must also specify a *name* for the compartment, which must be unique across all compartments in
your tenancy and cannot be changed. You can use this name or the OCID when writing policies that apply
to the compartment. For more information about policies, see
[How Policies Work](/Content/Identity/Concepts/policies.htm).

You must also specify a *description* for the compartment (although it can be an empty string). It does
not have to be unique, and you can change it anytime with
[UpdateCompartment](#/en/identity/20160918/Compartment/UpdateCompartment).

After you send your request, the new object's `lifecycleState` will temporarily be CREATING. Before using the
object, first make sure its `lifecycleState` has changed to ACTIVE.

*/
func (a *Client) CreateCompartment(params *CreateCompartmentParams) (*CreateCompartmentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateCompartmentParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateCompartment",
		Method:             "POST",
		PathPattern:        "/compartments/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateCompartmentReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateCompartmentOK), nil

}

/*
CreateGroup creates group

Creates a new group in your tenancy.

You must specify your tenancy's OCID as the compartment ID in the request object (remember that the tenancy
is simply the root compartment). Notice that IAM resources (users, groups, compartments, and some policies)
reside within the tenancy itself, unlike cloud resources such as compute instances, which typically
reside within compartments inside the tenancy. For information about OCIDs, see
[Resource Identifiers](/Content/General/Concepts/identifiers.htm).

You must also specify a *name* for the group, which must be unique across all groups in your tenancy and
cannot be changed. You can use this name or the OCID when writing policies that apply to the group. For more
information about policies, see [How Policies Work](/Content/Identity/Concepts/policies.htm).

You must also specify a *description* for the group (although it can be an empty string). It does not
have to be unique, and you can change it anytime with [UpdateGroup](#/en/identity/20160918/Group/UpdateGroup).

After you send your request, the new object's `lifecycleState` will temporarily be CREATING. Before using the
object, first make sure its `lifecycleState` has changed to ACTIVE.

After creating the group, you need to put users in it and write policies for it.
See [AddUserToGroup](#/en/identity/20160918/UserGroupMembership/AddUserToGroup) and
[CreatePolicy](#/en/identity/20160918/Policy/CreatePolicy).

*/
func (a *Client) CreateGroup(params *CreateGroupParams) (*CreateGroupOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateGroupParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateGroup",
		Method:             "POST",
		PathPattern:        "/groups/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateGroupReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateGroupOK), nil

}

/*
CreateIdentityProvider creates identity provider

Creates a new identity provider in your tenancy. For more information, see
[Identity Providers and Federation](/Content/Identity/Concepts/federation.htm).

You must specify your tenancy's OCID as the compartment ID in the request object.
Remember that the tenancy is simply the root compartment. For information about
OCIDs, see [Resource Identifiers](/Content/General/Concepts/identifiers.htm).

You must also specify a *name* for the `IdentityProvider`, which must be unique
across all `IdentityProvider` objects in your tenancy and cannot be changed.

You must also specify a *description* for the `IdentityProvider` (although
it can be an empty string). It does not have to be unique, and you can change
it anytime with
[UpdateIdentityProvider](#/en/identity/20160918/IdentityProvider/UpdateIdentityProvider).

After you send your request, the new object's `lifecycleState` will temporarily
be CREATING. Before using the object, first make sure its `lifecycleState` has
changed to ACTIVE.

*/
func (a *Client) CreateIdentityProvider(params *CreateIdentityProviderParams) (*CreateIdentityProviderOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateIdentityProviderParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateIdentityProvider",
		Method:             "POST",
		PathPattern:        "/identityProviders/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateIdentityProviderReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateIdentityProviderOK), nil

}

/*
CreateIdpGroupMapping creates idp group mapping

Creates a single mapping between an IdP group and an IAM Service
[group](#/en/identity/20160918/Group/).

*/
func (a *Client) CreateIdpGroupMapping(params *CreateIdpGroupMappingParams) (*CreateIdpGroupMappingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateIdpGroupMappingParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateIdpGroupMapping",
		Method:             "POST",
		PathPattern:        "/identityProviders/{identityProviderId}/groupMappings/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateIdpGroupMappingReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateIdpGroupMappingOK), nil

}

/*
CreateOrResetUipassword creates or reset uipassword

Creates a new Console one-time password for the specified user. For more information about user
credentials, see [User Credentials](/Content/Identity/Concepts/usercredentials.htm).

Use this operation after creating a new user, or if a user forgets their password. The new one-time
password is returned to you in the response, and you must securely deliver it to the user. They'll
be prompted to change this password the next time they sign in to the Console. If they don't change
it within 7 days, the password will expire and you'll need to create a new one-time password for the
user.

**Note:** The user's Console login is the unique name you specified when you created the user
(see [CreateUser](#/en/identity/20160918/User/CreateUser)).

*/
func (a *Client) CreateOrResetUipassword(params *CreateOrResetUipasswordParams) (*CreateOrResetUipasswordOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateOrResetUipasswordParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateOrResetUIPassword",
		Method:             "POST",
		PathPattern:        "/users/{userId}/uiPassword",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateOrResetUipasswordReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateOrResetUipasswordOK), nil

}

/*
CreatePolicy creates policy

Creates a new policy in the specified compartment (either the tenancy or another of your compartments).

If you're new to policies, see [Getting Started with Policies](/Content/Identity/Concepts/policygetstarted.htm).

You must specify a *name* for the policy, which must be unique across all policies in your tenancy
and cannot be changed.

You must also specify a *description* for the policy (although it can be an empty string). It does not
have to be unique, and you can change it anytime with [UpdatePolicy](#/en/identity/20160918/Policy/UpdatePolicy).

You must specify one or more policy statements in the statements array. For information about writing
policies, see [How Policies Work](/Content/Identity/Concepts/policies.htm) and
[Common Policies](/Content/Identity/Concepts/commonpolicies.htm).

After you send your request, the new object's `lifecycleState` will temporarily be CREATING. Before using the
object, first make sure its `lifecycleState` has changed to ACTIVE.

New policies take effect typically within 10 seconds.

*/
func (a *Client) CreatePolicy(params *CreatePolicyParams) (*CreatePolicyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreatePolicyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreatePolicy",
		Method:             "POST",
		PathPattern:        "/policies/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreatePolicyReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreatePolicyOK), nil

}

/*
CreateRegionSubscription creates region subscription

Create a new regionSubscription for tenancy
*/
func (a *Client) CreateRegionSubscription(params *CreateRegionSubscriptionParams) (*CreateRegionSubscriptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRegionSubscriptionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateRegionSubscription",
		Method:             "POST",
		PathPattern:        "/tenancies/{tenancyId}/regionSubscriptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateRegionSubscriptionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateRegionSubscriptionOK), nil

}

/*
CreateSwiftPassword creates swift password

Creates a new Swift password for the specified user. For information about what Swift passwords are for, see
[Managing User Credentials](/Content/Identity/Tasks/managingcredentials.htm).

You must specify a *description* for the Swift password (although it can be an empty string). It does not
have to be unique, and you can change it anytime with
[UpdateSwiftPassword](#/en/identity/20160918/SwiftPassword/UpdateSwiftPassword).

Every user has permission to create a Swift password for *their own user ID*. An administrator in your organization
does not need to write a policy to give users this ability. To compare, administrators who have permission to the
tenancy can use this operation to create a Swift password for any user, including themselves.

*/
func (a *Client) CreateSwiftPassword(params *CreateSwiftPasswordParams) (*CreateSwiftPasswordOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateSwiftPasswordParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateSwiftPassword",
		Method:             "POST",
		PathPattern:        "/users/{userId}/swiftPasswords/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateSwiftPasswordReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateSwiftPasswordOK), nil

}

/*
CreateUser creates user

Creates a new user in your tenancy. For conceptual information about users, your tenancy, and other
IAM Service components, see [Overview of the IAM Service](/Content/Identity/Concepts/overview.htm).

You must specify your tenancy's OCID as the compartment ID in the request object (remember that the
tenancy is simply the root compartment). Notice that IAM resources (users, groups, compartments, and
some policies) reside within the tenancy itself, unlike cloud resources such as compute instances,
which typically reside within compartments inside the tenancy. For information about OCIDs, see
[Resource Identifiers](/Content/General/Concepts/identifiers.htm).

You must also specify a *name* for the user, which must be unique across all users in your tenancy
and cannot be changed. Allowed characters: No spaces. Only letters, numerals, hyphens, periods,
underscores, +, and @. If you specify a name that's already in use, you'll get a 409 error.
This name will be the user's login to the Console. You might want to pick a
name that your company's own identity system (e.g., Active Directory, LDAP, etc.) already uses.
If you delete a user and then create a new user with the same name, they'll be considered different
users because they have different OCIDs.

You must also specify a *description* for the user (although it can be an empty string).
It does not have to be unique, and you can change it anytime with
[UpdateUser](#/en/identity/20160918/User/UpdateUser). You can use the field to provide the user's
full name, a description, a nickname, or other information to generally identify the user.

After you send your request, the new object's `lifecycleState` will temporarily be CREATING. Before
using the object, first make sure its `lifecycleState` has changed to ACTIVE.

A new user has no permissions until you place the user in one or more groups (see
[AddUserToGroup](#/en/identity/20160918/UserGroupMembership/AddUserToGroup)). If the user needs to
access the Console, you need to provide the user a password (see
[CreateOrResetUIPassword](#/en/identity/20160918/UIPassword/CreateOrResetUIPassword)).
If the user needs to access the Oracle Bare Metal Cloud Services REST API, you need to upload a
public API signing key for that user (see
[Required Keys and OCIDs](/Content/API/Concepts/apisigningkey.htm) and also
[UploadApiKey](#/en/identity/20160918/ApiKey/UploadApiKey)).

**Important:** Make sure to inform the new user which compartment(s) they have access to.

*/
func (a *Client) CreateUser(params *CreateUserParams) (*CreateUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateUserParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateUser",
		Method:             "POST",
		PathPattern:        "/users/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateUserReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateUserOK), nil

}

/*
DeleteAPIKey deletes Api key

Deletes the specified API signing key for the specified user.

Every user has permission to use this operation to delete a key for *their own user ID*. An
administrator in your organization does not need to write a policy to give users this ability.
To compare, administrators who have permission to the tenancy can use this operation to delete
a key for any user, including themselves.

*/
func (a *Client) DeleteAPIKey(params *DeleteAPIKeyParams) (*DeleteAPIKeyNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteAPIKeyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteApiKey",
		Method:             "DELETE",
		PathPattern:        "/users/{userId}/apiKeys/{fingerprint}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteAPIKeyReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteAPIKeyNoContent), nil

}

/*
DeleteGroup deletes group

Deletes the specified group. The group must be empty.

*/
func (a *Client) DeleteGroup(params *DeleteGroupParams) (*DeleteGroupNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteGroupParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteGroup",
		Method:             "DELETE",
		PathPattern:        "/groups/{groupId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteGroupReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteGroupNoContent), nil

}

/*
DeleteIdentityProvider deletes identity provider

Deletes the specified identity provider. The identity provider must not have
any group mappings (see [IdpGroupMapping](#/en/identity/20160918/IdpGroupMapping/)).

*/
func (a *Client) DeleteIdentityProvider(params *DeleteIdentityProviderParams) (*DeleteIdentityProviderNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteIdentityProviderParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteIdentityProvider",
		Method:             "DELETE",
		PathPattern:        "/identityProviders/{identityProviderId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteIdentityProviderReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteIdentityProviderNoContent), nil

}

/*
DeleteIdpGroupMapping deletes idp group mapping

Deletes the specified group mapping.
*/
func (a *Client) DeleteIdpGroupMapping(params *DeleteIdpGroupMappingParams) (*DeleteIdpGroupMappingNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteIdpGroupMappingParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteIdpGroupMapping",
		Method:             "DELETE",
		PathPattern:        "/identityProviders/{identityProviderId}/groupMappings/{mappingId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteIdpGroupMappingReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteIdpGroupMappingNoContent), nil

}

/*
DeletePolicy deletes policy

Deletes the specified policy. The deletion takes effect typically within 10 seconds.
*/
func (a *Client) DeletePolicy(params *DeletePolicyParams) (*DeletePolicyNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeletePolicyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeletePolicy",
		Method:             "DELETE",
		PathPattern:        "/policies/{policyId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeletePolicyReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeletePolicyNoContent), nil

}

/*
DeleteSwiftPassword deletes swift password

Deletes the specified Swift password for the specified user.

*/
func (a *Client) DeleteSwiftPassword(params *DeleteSwiftPasswordParams) (*DeleteSwiftPasswordNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteSwiftPasswordParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteSwiftPassword",
		Method:             "DELETE",
		PathPattern:        "/users/{userId}/swiftPasswords/{swiftPasswordId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteSwiftPasswordReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteSwiftPasswordNoContent), nil

}

/*
DeleteUser deletes user

Deletes the specified user. The user must not be in any groups.
*/
func (a *Client) DeleteUser(params *DeleteUserParams) (*DeleteUserNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteUserParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteUser",
		Method:             "DELETE",
		PathPattern:        "/users/{userId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteUserReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteUserNoContent), nil

}

/*
GetCompartment gets compartment

Gets the specified compartment's information.

This operation does not return a list of all the resources inside the compartment. There is no single
API operation that does that. Compartments can contain multiple types of resources (instances, block
storage volumes, etc.). To find out what's in a compartment, you must call the "List" operation for
each resource type and specify the compartment's OCID as a query parameter in the request. For example,
call the [ListInstances](#/en/iaas/20160918/Instance/ListInstances) operation in the Cloud Compute
Service or the [ListVolumes](#/en/iaas/20160918/Volume/ListVolumes) operation in Cloud Block Storage.

*/
func (a *Client) GetCompartment(params *GetCompartmentParams) (*GetCompartmentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCompartmentParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetCompartment",
		Method:             "GET",
		PathPattern:        "/compartments/{compartmentId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetCompartmentReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetCompartmentOK), nil

}

/*
GetGroup gets group

Gets the specified group's information.

This operation does not return a list of all the users in the group. To do that, use
[ListUserGroupMemberships](#/en/identity/20160918/UserGroupMembership/ListUserGroupMemberships) and
provide the group's OCID as a query parameter in the request.

*/
func (a *Client) GetGroup(params *GetGroupParams) (*GetGroupOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetGroupParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetGroup",
		Method:             "GET",
		PathPattern:        "/groups/{groupId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetGroupReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetGroupOK), nil

}

/*
GetIdentityProvider gets identity provider

Gets the specified identity provider's information.
*/
func (a *Client) GetIdentityProvider(params *GetIdentityProviderParams) (*GetIdentityProviderOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetIdentityProviderParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetIdentityProvider",
		Method:             "GET",
		PathPattern:        "/identityProviders/{identityProviderId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetIdentityProviderReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetIdentityProviderOK), nil

}

/*
GetIdpGroupMapping gets idp group mapping

Gets the specified group mapping.
*/
func (a *Client) GetIdpGroupMapping(params *GetIdpGroupMappingParams) (*GetIdpGroupMappingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetIdpGroupMappingParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetIdpGroupMapping",
		Method:             "GET",
		PathPattern:        "/identityProviders/{identityProviderId}/groupMappings/{mappingId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetIdpGroupMappingReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetIdpGroupMappingOK), nil

}

/*
GetPolicy gets policy

Gets the specified policy's information.
*/
func (a *Client) GetPolicy(params *GetPolicyParams) (*GetPolicyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPolicyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetPolicy",
		Method:             "GET",
		PathPattern:        "/policies/{policyId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetPolicyReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetPolicyOK), nil

}

/*
GetTenancy gets tenancy

Get the specified tenancy's information.
*/
func (a *Client) GetTenancy(params *GetTenancyParams) (*GetTenancyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetTenancyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetTenancy",
		Method:             "GET",
		PathPattern:        "/tenancies/{tenancyId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetTenancyReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetTenancyOK), nil

}

/*
GetUser gets user

Gets the specified user's information.
*/
func (a *Client) GetUser(params *GetUserParams) (*GetUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUserParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetUser",
		Method:             "GET",
		PathPattern:        "/users/{userId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetUserReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetUserOK), nil

}

/*
GetUserGroupMembership gets user group membership

Gets the specified UserGroupMembership's information.
*/
func (a *Client) GetUserGroupMembership(params *GetUserGroupMembershipParams) (*GetUserGroupMembershipOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUserGroupMembershipParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetUserGroupMembership",
		Method:             "GET",
		PathPattern:        "/userGroupMemberships/{userGroupMembershipId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetUserGroupMembershipReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetUserGroupMembershipOK), nil

}

/*
ListAPIKeys lists Api keys

Lists the API signing keys for the specified user. A user can have a maximum of three keys.

Every user has permission to use this API call for *their own user ID*.  An administrator in your
organization does not need to write a policy to give users this ability.

*/
func (a *Client) ListAPIKeys(params *ListAPIKeysParams) (*ListAPIKeysOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListAPIKeysParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListApiKeys",
		Method:             "GET",
		PathPattern:        "/users/{userId}/apiKeys/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListAPIKeysReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListAPIKeysOK), nil

}

/*
ListAvailabilityDomains lists availability domains

Lists the Availability Domains in your tenancy. Specify the OCID of either the tenancy or another
of your compartments as the value for the compartment ID (remember that the tenancy is simply the root compartment).
See [Where to Get the Tenancy's OCID and User's OCID](/Content/API/Concepts/apisigningkey.htm#five).

*/
func (a *Client) ListAvailabilityDomains(params *ListAvailabilityDomainsParams) (*ListAvailabilityDomainsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListAvailabilityDomainsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListAvailabilityDomains",
		Method:             "GET",
		PathPattern:        "/availabilityDomains/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListAvailabilityDomainsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListAvailabilityDomainsOK), nil

}

/*
ListCompartments lists compartments

Lists the compartments in your tenancy. You must specify your tenancy's OCID as the value
for the compartment ID (remember that the tenancy is simply the root compartment).
See [Where to Get the Tenancy's OCID and User's OCID](/Content/API/Concepts/apisigningkey.htm#five).

*/
func (a *Client) ListCompartments(params *ListCompartmentsParams) (*ListCompartmentsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListCompartmentsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListCompartments",
		Method:             "GET",
		PathPattern:        "/compartments/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListCompartmentsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListCompartmentsOK), nil

}

/*
ListGroups lists groups

Lists the groups in your tenancy. You must specify your tenancy's OCID as the value for
the compartment ID (remember that the tenancy is simply the root compartment).
See [Where to Get the Tenancy's OCID and User's OCID](/Content/API/Concepts/apisigningkey.htm#five).

*/
func (a *Client) ListGroups(params *ListGroupsParams) (*ListGroupsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListGroupsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListGroups",
		Method:             "GET",
		PathPattern:        "/groups/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListGroupsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListGroupsOK), nil

}

/*
ListIdentityProviders lists identity providers

Lists all the identity providers in your tenancy. You must specify the identity provider type (e.g., `SAML2` for
identity providers using the SAML2.0 protocol). You must specify your tenancy's OCID as the value for the
compartment ID (remember that the tenancy is simply the root compartment).
See [Where to Get the Tenancy's OCID and User's OCID](/Content/API/Concepts/apisigningkey.htm#five).

*/
func (a *Client) ListIdentityProviders(params *ListIdentityProvidersParams) (*ListIdentityProvidersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListIdentityProvidersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListIdentityProviders",
		Method:             "GET",
		PathPattern:        "/identityProviders/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListIdentityProvidersReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListIdentityProvidersOK), nil

}

/*
ListIdpGroupMappings lists idp group mappings

Lists the group mappings for the specified identity provider.

*/
func (a *Client) ListIdpGroupMappings(params *ListIdpGroupMappingsParams) (*ListIdpGroupMappingsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListIdpGroupMappingsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListIdpGroupMappings",
		Method:             "GET",
		PathPattern:        "/identityProviders/{identityProviderId}/groupMappings/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListIdpGroupMappingsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListIdpGroupMappingsOK), nil

}

/*
ListPolicies lists policies

Lists the policies in the specified compartment (either the tenancy or another of your compartments).
See [Where to Get the Tenancy's OCID and User's OCID](/Content/API/Concepts/apisigningkey.htm#five).

To determine which policies apply to a particular group or compartment, you must view the individual
statements inside all your policies. There isn't a way to automatically obtain that information via the API.

To use this and other API operations, you must be authorized in an IAM policy. If you're not authorized,
talk to an administrator. If you're an administrator who needs to write policies to give users access, see
[Getting Started with Policies](/Content/Identity/Concepts/policygetstarted.htm).

*/
func (a *Client) ListPolicies(params *ListPoliciesParams) (*ListPoliciesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListPoliciesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListPolicies",
		Method:             "GET",
		PathPattern:        "/policies/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListPoliciesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListPoliciesOK), nil

}

/*
ListRegionSubscriptions lists region subscriptions

Retrive the region subscriptions for the specific tenancy
*/
func (a *Client) ListRegionSubscriptions(params *ListRegionSubscriptionsParams) (*ListRegionSubscriptionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListRegionSubscriptionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListRegionSubscriptions",
		Method:             "GET",
		PathPattern:        "/tenancies/{tenancyId}/regionSubscriptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListRegionSubscriptionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListRegionSubscriptionsOK), nil

}

/*
ListRegions lists regions

List all the regions
*/
func (a *Client) ListRegions(params *ListRegionsParams) (*ListRegionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListRegionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListRegions",
		Method:             "GET",
		PathPattern:        "/regions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListRegionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListRegionsOK), nil

}

/*
ListSwiftPasswords lists swift passwords

Lists the Swift passwords for the specified user. The returned object contains the password's OCID, but not
the password itself. The actual password is returned only upon creation.

*/
func (a *Client) ListSwiftPasswords(params *ListSwiftPasswordsParams) (*ListSwiftPasswordsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListSwiftPasswordsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListSwiftPasswords",
		Method:             "GET",
		PathPattern:        "/users/{userId}/swiftPasswords/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListSwiftPasswordsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListSwiftPasswordsOK), nil

}

/*
ListUserGroupMemberships lists user group memberships

Lists the `UserGroupMembership` objects in your tenancy. You must specify your tenancy's OCID
as the value for the compartment ID
(see [Where to Get the Tenancy's OCID and User's OCID](/Content/API/Concepts/apisigningkey.htm#five)).
You must also then filter the list in one of these ways:

- You can limit the results to just the memberships for a given user by specifying a `userId`.
- Similarly, you can limit the results to just the memberships for a given group by specifying a `groupId`.
- You can set both the `userId` and `groupId` to determine if the specified user is in the specified group.
If the answer is no, the response is an empty list.

*/
func (a *Client) ListUserGroupMemberships(params *ListUserGroupMembershipsParams) (*ListUserGroupMembershipsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListUserGroupMembershipsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListUserGroupMemberships",
		Method:             "GET",
		PathPattern:        "/userGroupMemberships/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListUserGroupMembershipsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListUserGroupMembershipsOK), nil

}

/*
ListUsers lists users

Lists the users in your tenancy. You must specify your tenancy's OCID as the value for the
compartment ID (remember that the tenancy is simply the root compartment).
See [Where to Get the Tenancy's OCID and User's OCID](/Content/API/Concepts/apisigningkey.htm#five).

*/
func (a *Client) ListUsers(params *ListUsersParams) (*ListUsersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListUsersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListUsers",
		Method:             "GET",
		PathPattern:        "/users/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListUsersReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListUsersOK), nil

}

/*
RemoveUserFromGroup removes user from group

Removes a user from a group by deleting the corresponding `UserGroupMembership`.
*/
func (a *Client) RemoveUserFromGroup(params *RemoveUserFromGroupParams) (*RemoveUserFromGroupNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoveUserFromGroupParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "RemoveUserFromGroup",
		Method:             "DELETE",
		PathPattern:        "/userGroupMemberships/{userGroupMembershipId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RemoveUserFromGroupReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RemoveUserFromGroupNoContent), nil

}

/*
UpdateCompartment updates compartment

Updates the specified compartment's description.
*/
func (a *Client) UpdateCompartment(params *UpdateCompartmentParams) (*UpdateCompartmentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateCompartmentParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateCompartment",
		Method:             "PUT",
		PathPattern:        "/compartments/{compartmentId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateCompartmentReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateCompartmentOK), nil

}

/*
UpdateGroup updates group

Updates the specified group.
*/
func (a *Client) UpdateGroup(params *UpdateGroupParams) (*UpdateGroupOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateGroupParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateGroup",
		Method:             "PUT",
		PathPattern:        "/groups/{groupId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateGroupReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateGroupOK), nil

}

/*
UpdateIdentityProvider updates identity provider

Updates the specified identity provider.
*/
func (a *Client) UpdateIdentityProvider(params *UpdateIdentityProviderParams) (*UpdateIdentityProviderOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateIdentityProviderParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateIdentityProvider",
		Method:             "PUT",
		PathPattern:        "/identityProviders/{identityProviderId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateIdentityProviderReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateIdentityProviderOK), nil

}

/*
UpdateIdpGroupMapping updates idp group mapping

Updates the specified group mapping.
*/
func (a *Client) UpdateIdpGroupMapping(params *UpdateIdpGroupMappingParams) (*UpdateIdpGroupMappingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateIdpGroupMappingParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateIdpGroupMapping",
		Method:             "PUT",
		PathPattern:        "/identityProviders/{identityProviderId}/groupMappings/{mappingId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateIdpGroupMappingReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateIdpGroupMappingOK), nil

}

/*
UpdatePolicy updates policy

Updates the specified policy. You can update the description or the policy statements themselves.

Policy changes take effect typically within 10 seconds.

*/
func (a *Client) UpdatePolicy(params *UpdatePolicyParams) (*UpdatePolicyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdatePolicyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdatePolicy",
		Method:             "PUT",
		PathPattern:        "/policies/{policyId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdatePolicyReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdatePolicyOK), nil

}

/*
UpdateSwiftPassword updates swift password

Updates the specified Swift password's description.

*/
func (a *Client) UpdateSwiftPassword(params *UpdateSwiftPasswordParams) (*UpdateSwiftPasswordOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateSwiftPasswordParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateSwiftPassword",
		Method:             "PUT",
		PathPattern:        "/users/{userId}/swiftPasswords/{swiftPasswordId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateSwiftPasswordReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateSwiftPasswordOK), nil

}

/*
UpdateUser updates user

Updates the description of the specified user.
*/
func (a *Client) UpdateUser(params *UpdateUserParams) (*UpdateUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateUserParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateUser",
		Method:             "PUT",
		PathPattern:        "/users/{userId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateUserReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateUserOK), nil

}

/*
UpdateUserState updates user state

Updates the state of the specified user.

*/
func (a *Client) UpdateUserState(params *UpdateUserStateParams) (*UpdateUserStateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateUserStateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateUserState",
		Method:             "PUT",
		PathPattern:        "/users/{userId}/state/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateUserStateReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateUserStateOK), nil

}

/*
UploadAPIKey uploads Api key

Uploads an API signing key for the specified user.

Every user has permission to use this operation to upload a key for *their own user ID*. An
administrator in your organization does not need to write a policy to give users this ability.
To compare, administrators who have permission to the tenancy can use this operation to upload a
key for any user, including themselves.

**Important:** Even though you have permission to upload an API key, you might not yet
have permission to do much else. If you try calling an operation unrelated to your own credential
management (e.g., `ListUsers`, `LaunchInstance`) and receive an "unauthorized" error,
check with an administrator to confirm which IAM Service group(s) you're in and what access
you have. Also confirm you're working in the correct compartment.

After you send your request, the new object's `lifecycleState` will temporarily be CREATING. Before using
the object, first make sure its `lifecycleState` has changed to ACTIVE.

*/
func (a *Client) UploadAPIKey(params *UploadAPIKeyParams) (*UploadAPIKeyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUploadAPIKeyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UploadApiKey",
		Method:             "POST",
		PathPattern:        "/users/{userId}/apiKeys/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UploadAPIKeyReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UploadAPIKeyOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
