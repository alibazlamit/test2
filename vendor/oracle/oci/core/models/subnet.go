package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Subnet A logical subdivision of a VCN. Each subnet exists in a single Availability Domain and
// consists of a contiguous range of IP addresses that do not overlap with
// other subnets in the VCN. Example: 172.16.1.0/24. For more information, see
// [Overview of the Networking Service](/Content/Network/Concepts/overview.htm) and
// [Managing Subnets](/Content/Network/Tasks/managingsubnets.htm).
//
// To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized,
// talk to an administrator. If you're an administrator who needs to write policies to give users access, see
// [Getting Started with Policies](/Content/Identity/Concepts/policygetstarted.htm).
//
// swagger:model Subnet
type Subnet struct {

	// The subnet's Availability Domain.
	//
	// Example: `Uocm:PHX-AD-1`
	//
	// Required: true
	// Max Length: 255
	// Min Length: 1
	AvailabilityDomain *string `json:"availabilityDomain"`

	// The subnet's CIDR block.
	//
	// Example: `172.16.1.0/24`
	//
	// Required: true
	// Max Length: 32
	// Min Length: 1
	CidrBlock *string `json:"cidrBlock"`

	// The OCID of the compartment containing the subnet.
	// Required: true
	// Max Length: 255
	// Min Length: 1
	CompartmentID *string `json:"compartmentId"`

	// The OCID of the set of DHCP options associated with the subnet.
	//
	// Max Length: 255
	// Min Length: 1
	DhcpOptionsID string `json:"dhcpOptionsId,omitempty"`

	// A user-friendly name. Does not have to be unique, and it's changeable.
	// Avoid entering confidential information.
	//
	// Max Length: 255
	// Min Length: 1
	DisplayName string `json:"displayName,omitempty"`

	// A DNS label for the subnet, used in conjunction with the VNIC's hostname and
	// VCN's DNS label to form a fully qualified domain name (FQDN) for each VNIC
	// within this subnet (e.g., `bminstance-1.subnet123.vcn1.oraclevcn.com`).
	// Must be an alphanumeric string that begins with a letter and is unique within the VCN.
	// The value cannot be changed.
	//
	// The absence of this parameter means the Internet and VCN Resolver
	// will not resolve hostnames of instances in this subnet.
	//
	// For more information, see
	// [DNS in Your Virtual Cloud Network](/Content/Network/Concepts/dns.htm).
	//
	// Example: `subnet123`
	//
	// Max Length: 15
	// Min Length: 1
	DNSLabel string `json:"dnsLabel,omitempty"`

	// The subnet's Oracle ID (OCID).
	// Required: true
	// Max Length: 255
	// Min Length: 1
	ID *string `json:"id"`

	// The subnet's current state.
	// Required: true
	LifecycleState *string `json:"lifecycleState"`

	// Whether VNICs within this subnet can have public IP addresses.
	// Defaults to false, which means VNICs created in this subnet will
	// automatically be assigned public IP addresses unless specified
	// otherwise during instance launch or VNIC creation (with the
	// `assignPublicIp` flag in
	// [CreateVnicDetails](#/en/iaas/20160918/CreateVnicDetails/)).
	// If `prohibitPublicIpOnVnic` is set to true, VNICs created in this
	// subnet cannot have public IP addresses (i.e., it's a private
	// subnet).
	//
	// Example: `true`
	//
	ProhibitPublicIPOnVnic bool `json:"prohibitPublicIpOnVnic,omitempty"`

	// The OCID of the route table the subnet is using.
	// Required: true
	// Max Length: 255
	// Min Length: 1
	RouteTableID *string `json:"routeTableId"`

	// OCIDs for the security lists to use for VNICs in this subnet.
	SecurityListIds []string `json:"securityListIds"`

	// The subnet's domain name, which consists of the subnet's DNS label,
	// the VCN's DNS label, and the `oraclevcn.com` domain.
	//
	// For more information, see
	// [DNS in Your Virtual Cloud Network](/Content/Network/Concepts/dns.htm).
	//
	// Example: `subnet123.vcn1.oraclevcn.com`
	//
	// Max Length: 253
	// Min Length: 1
	SubnetDomainName string `json:"subnetDomainName,omitempty"`

	// The date and time the subnet was created, in the format defined by RFC3339.
	//
	// Example: `2016-08-25T21:10:29.600Z`
	//
	TimeCreated strfmt.DateTime `json:"timeCreated,omitempty"`

	// The OCID of the VCN the subnet is in.
	// Required: true
	// Max Length: 255
	// Min Length: 1
	VcnID *string `json:"vcnId"`

	// The IP address of the virtual router.
	//
	// Example: `10.0.14.1`
	//
	// Required: true
	// Max Length: 32
	// Min Length: 1
	VirtualRouterIP *string `json:"virtualRouterIp"`

	// The MAC address of the virtual router.
	//
	// Example: `00:00:17:B6:4D:DD`
	//
	// Required: true
	// Max Length: 32
	// Min Length: 1
	VirtualRouterMac *string `json:"virtualRouterMac"`
}

// Validate validates this subnet
func (m *Subnet) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAvailabilityDomain(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCidrBlock(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCompartmentID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDhcpOptionsID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDisplayName(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDNSLabel(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLifecycleState(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRouteTableID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSecurityListIds(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSubnetDomainName(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateVcnID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateVirtualRouterIP(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateVirtualRouterMac(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Subnet) validateAvailabilityDomain(formats strfmt.Registry) error {

	if err := validate.Required("availabilityDomain", "body", m.AvailabilityDomain); err != nil {
		return err
	}

	if err := validate.MinLength("availabilityDomain", "body", string(*m.AvailabilityDomain), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("availabilityDomain", "body", string(*m.AvailabilityDomain), 255); err != nil {
		return err
	}

	return nil
}

func (m *Subnet) validateCidrBlock(formats strfmt.Registry) error {

	if err := validate.Required("cidrBlock", "body", m.CidrBlock); err != nil {
		return err
	}

	if err := validate.MinLength("cidrBlock", "body", string(*m.CidrBlock), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("cidrBlock", "body", string(*m.CidrBlock), 32); err != nil {
		return err
	}

	return nil
}

func (m *Subnet) validateCompartmentID(formats strfmt.Registry) error {

	if err := validate.Required("compartmentId", "body", m.CompartmentID); err != nil {
		return err
	}

	if err := validate.MinLength("compartmentId", "body", string(*m.CompartmentID), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("compartmentId", "body", string(*m.CompartmentID), 255); err != nil {
		return err
	}

	return nil
}

func (m *Subnet) validateDhcpOptionsID(formats strfmt.Registry) error {

	if swag.IsZero(m.DhcpOptionsID) { // not required
		return nil
	}

	if err := validate.MinLength("dhcpOptionsId", "body", string(m.DhcpOptionsID), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("dhcpOptionsId", "body", string(m.DhcpOptionsID), 255); err != nil {
		return err
	}

	return nil
}

func (m *Subnet) validateDisplayName(formats strfmt.Registry) error {

	if swag.IsZero(m.DisplayName) { // not required
		return nil
	}

	if err := validate.MinLength("displayName", "body", string(m.DisplayName), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("displayName", "body", string(m.DisplayName), 255); err != nil {
		return err
	}

	return nil
}

func (m *Subnet) validateDNSLabel(formats strfmt.Registry) error {

	if swag.IsZero(m.DNSLabel) { // not required
		return nil
	}

	if err := validate.MinLength("dnsLabel", "body", string(m.DNSLabel), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("dnsLabel", "body", string(m.DNSLabel), 15); err != nil {
		return err
	}

	return nil
}

func (m *Subnet) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	if err := validate.MinLength("id", "body", string(*m.ID), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("id", "body", string(*m.ID), 255); err != nil {
		return err
	}

	return nil
}

var subnetTypeLifecycleStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PROVISIONING","AVAILABLE","TERMINATING","TERMINATED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		subnetTypeLifecycleStatePropEnum = append(subnetTypeLifecycleStatePropEnum, v)
	}
}

const (
	// SubnetLifecycleStatePROVISIONING captures enum value "PROVISIONING"
	SubnetLifecycleStatePROVISIONING string = "PROVISIONING"
	// SubnetLifecycleStateAVAILABLE captures enum value "AVAILABLE"
	SubnetLifecycleStateAVAILABLE string = "AVAILABLE"
	// SubnetLifecycleStateTERMINATING captures enum value "TERMINATING"
	SubnetLifecycleStateTERMINATING string = "TERMINATING"
	// SubnetLifecycleStateTERMINATED captures enum value "TERMINATED"
	SubnetLifecycleStateTERMINATED string = "TERMINATED"
)

// prop value enum
func (m *Subnet) validateLifecycleStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, subnetTypeLifecycleStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Subnet) validateLifecycleState(formats strfmt.Registry) error {

	if err := validate.Required("lifecycleState", "body", m.LifecycleState); err != nil {
		return err
	}

	// value enum
	if err := m.validateLifecycleStateEnum("lifecycleState", "body", *m.LifecycleState); err != nil {
		return err
	}

	return nil
}

func (m *Subnet) validateRouteTableID(formats strfmt.Registry) error {

	if err := validate.Required("routeTableId", "body", m.RouteTableID); err != nil {
		return err
	}

	if err := validate.MinLength("routeTableId", "body", string(*m.RouteTableID), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("routeTableId", "body", string(*m.RouteTableID), 255); err != nil {
		return err
	}

	return nil
}

func (m *Subnet) validateSecurityListIds(formats strfmt.Registry) error {

	if swag.IsZero(m.SecurityListIds) { // not required
		return nil
	}

	for i := 0; i < len(m.SecurityListIds); i++ {

		if err := validate.MinLength("securityListIds"+"."+strconv.Itoa(i), "body", string(m.SecurityListIds[i]), 1); err != nil {
			return err
		}

		if err := validate.MaxLength("securityListIds"+"."+strconv.Itoa(i), "body", string(m.SecurityListIds[i]), 255); err != nil {
			return err
		}

	}

	return nil
}

func (m *Subnet) validateSubnetDomainName(formats strfmt.Registry) error {

	if swag.IsZero(m.SubnetDomainName) { // not required
		return nil
	}

	if err := validate.MinLength("subnetDomainName", "body", string(m.SubnetDomainName), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("subnetDomainName", "body", string(m.SubnetDomainName), 253); err != nil {
		return err
	}

	return nil
}

func (m *Subnet) validateVcnID(formats strfmt.Registry) error {

	if err := validate.Required("vcnId", "body", m.VcnID); err != nil {
		return err
	}

	if err := validate.MinLength("vcnId", "body", string(*m.VcnID), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("vcnId", "body", string(*m.VcnID), 255); err != nil {
		return err
	}

	return nil
}

func (m *Subnet) validateVirtualRouterIP(formats strfmt.Registry) error {

	if err := validate.Required("virtualRouterIp", "body", m.VirtualRouterIP); err != nil {
		return err
	}

	if err := validate.MinLength("virtualRouterIp", "body", string(*m.VirtualRouterIP), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("virtualRouterIp", "body", string(*m.VirtualRouterIP), 32); err != nil {
		return err
	}

	return nil
}

func (m *Subnet) validateVirtualRouterMac(formats strfmt.Registry) error {

	if err := validate.Required("virtualRouterMac", "body", m.VirtualRouterMac); err != nil {
		return err
	}

	if err := validate.MinLength("virtualRouterMac", "body", string(*m.VirtualRouterMac), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("virtualRouterMac", "body", string(*m.VirtualRouterMac), 32); err != nil {
		return err
	}

	return nil
}
