package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// IcmpOptions Optional object to specify a particular ICMP type and code. If you specify ICMP as the protocol
// but do not provide this object, then all ICMP types and codes are allowed. If you do provide
// this object, the type is required and the code is optional.
// See [ICMP Parameters](http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml)
// for allowed values. To enable MTU negotiation for ingress internet traffic, make sure to allow
// type 3 ("Destination Unreachable") code 4 ("Fragmentation Needed and Don't Fragment was Set").
// If you need to specify multiple codes for a single type, create a separate security list rule for each.
//
// swagger:model IcmpOptions
type IcmpOptions struct {

	// The ICMP code (optional).
	// Maximum: 16
	// Minimum: 0
	Code *int64 `json:"code,omitempty"`

	// The ICMP type.
	// Required: true
	// Maximum: 254
	// Minimum: 0
	Type *int64 `json:"type"`
}

// Validate validates this icmp options
func (m *IcmpOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCode(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IcmpOptions) validateCode(formats strfmt.Registry) error {

	if swag.IsZero(m.Code) { // not required
		return nil
	}

	if err := validate.MinimumInt("code", "body", int64(*m.Code), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("code", "body", int64(*m.Code), 16, false); err != nil {
		return err
	}

	return nil
}

func (m *IcmpOptions) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	if err := validate.MinimumInt("type", "body", int64(*m.Type), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("type", "body", int64(*m.Type), 254, false); err != nil {
		return err
	}

	return nil
}
