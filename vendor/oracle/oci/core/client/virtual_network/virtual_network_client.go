package virtual_network

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new virtual network API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for virtual network API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
CreateCpe creates cpe

Creates a new virtual Customer-Premises Equipment (CPE) object in the specified compartment. For
more information, see [Managing IPSec VPNs](/Content/Network/Tasks/managingIPsec.htm).

For the purposes of access control, you must provide the OCID of the compartment where you want
the CPE to reside. Notice that the CPE doesn't have to be in the same compartment as the IPSec
connection or other Networking Service components. If you're not sure which compartment to
use, put the CPE in the same compartment as the DRG. For more information about
compartments and access control, see [Overview of the IAM Service](/Content/Identity/Concepts/overview.htm).
For information about OCIDs, see [Resource Identifiers](/Content/General/Concepts/identifiers.htm).

You must provide the public IP address of your on-premise router. See
[Configuring Your On-Premise Router](/Content/Network/Tasks/configuringCPE.htm).

You may optionally specify a *display name* for the CPE, otherwise a default is provided. It does not have to
be unique, and you can change it. Avoid entering confidential information.

*/
func (a *Client) CreateCpe(params *CreateCpeParams) (*CreateCpeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateCpeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateCpe",
		Method:             "POST",
		PathPattern:        "/cpes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateCpeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateCpeOK), nil

}

/*
CreateCrossConnect creates cross connect

Creates a new cross-connect. Oracle recommends you create each cross-connect in a
[CrossConnectGroup](#/en/iaas/20160918/CrossConnectGroup) so you can use link aggregation
with the connection.

After creating the `CrossConnect` object, you need to go the FastConnect location
and request to have the physical cable installed. For more information, see
[FastConnect Overview](/Content/Network/Concepts/fastconnect.htm).

For the purposes of access control, you must provide the OCID of the
compartment where you want the cross-connect to reside. If you're
not sure which compartment to use, put the cross-connect in the
same compartment with your VCN. For more information about
compartments and access control, see
[Overview of the IAM Service](/Content/Identity/Concepts/overview.htm).
For information about OCIDs, see
[Resource Identifiers](/Content/General/Concepts/identifiers.htm).

You may optionally specify a *display name* for the cross-connect.
It does not have to be unique, and you can change it. Avoid entering confidential information.

*/
func (a *Client) CreateCrossConnect(params *CreateCrossConnectParams) (*CreateCrossConnectOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateCrossConnectParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateCrossConnect",
		Method:             "POST",
		PathPattern:        "/crossConnects",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateCrossConnectReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateCrossConnectOK), nil

}

/*
CreateCrossConnectGroup creates cross connect group

Creates a new cross-connect group to use with Oracle Bare Metal Cloud Services
FastConnect. For more information, see
[FastConnect Overview](/Content/Network/Concepts/fastconnect.htm).

For the purposes of access control, you must provide the OCID of the
compartment where you want the cross-connect group to reside. If you're
not sure which compartment to use, put the cross-connect group in the
same compartment with your VCN. For more information about
compartments and access control, see
[Overview of the IAM Service](/Content/Identity/Concepts/overview.htm).
For information about OCIDs, see
[Resource Identifiers](/Content/General/Concepts/identifiers.htm).

You may optionally specify a *display name* for the cross-connect group.
It does not have to be unique, and you can change it. Avoid entering confidential information.

*/
func (a *Client) CreateCrossConnectGroup(params *CreateCrossConnectGroupParams) (*CreateCrossConnectGroupOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateCrossConnectGroupParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateCrossConnectGroup",
		Method:             "POST",
		PathPattern:        "/crossConnectGroups",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateCrossConnectGroupReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateCrossConnectGroupOK), nil

}

/*
CreateDhcpOptions creates dhcp options

Creates a new set of DHCP options for the specified VCN. For more information, see
[DhcpOptions](#/en/iaas/20160918/DhcpOptions/).

For the purposes of access control, you must provide the OCID of the compartment where you want the set of
DHCP options to reside. Notice that the set of options doesn't have to be in the same compartment as the VCN,
subnets, or other Networking Service components. If you're not sure which compartment to use, put the set
of DHCP options in the same compartment as the VCN. For more information about compartments and access control, see
[Overview of the IAM Service](/Content/Identity/Concepts/overview.htm). For information about OCIDs, see
[Resource Identifiers](/Content/General/Concepts/identifiers.htm).

You may optionally specify a *display name* for the set of DHCP options, otherwise a default is provided.
It does not have to be unique, and you can change it. Avoid entering confidential information.

*/
func (a *Client) CreateDhcpOptions(params *CreateDhcpOptionsParams) (*CreateDhcpOptionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateDhcpOptionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateDhcpOptions",
		Method:             "POST",
		PathPattern:        "/dhcps",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateDhcpOptionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateDhcpOptionsOK), nil

}

/*
CreateDrg creates drg

Creates a new Dynamic Routing Gateway (DRG) in the specified compartment. For more information,
see [Managing Dynamic Routing Gateways (DRGs)](/Content/Network/Tasks/managingDRGs.htm).

For the purposes of access control, you must provide the OCID of the compartment where you want
the DRG to reside. Notice that the DRG doesn't have to be in the same compartment as the VCN,
the DRG attachment, or other Networking Service components. If you're not sure which compartment
to use, put the DRG in the same compartment as the VCN. For more information about compartments
and access control, see [Overview of the IAM Service](/Content/Identity/Concepts/overview.htm).
For information about OCIDs, see [Resource Identifiers](/Content/General/Concepts/identifiers.htm).

You may optionally specify a *display name* for the DRG, otherwise a default is provided.
It does not have to be unique, and you can change it. Avoid entering confidential information.

*/
func (a *Client) CreateDrg(params *CreateDrgParams) (*CreateDrgOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateDrgParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateDrg",
		Method:             "POST",
		PathPattern:        "/drgs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateDrgReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateDrgOK), nil

}

/*
CreateDrgAttachment creates drg attachment

Attaches the specified DRG to the specified VCN. A VCN can be attached to only one DRG at a time,
and vice versa. The response includes a `DrgAttachment` object with its own OCID. For more
information about DRGs, see
[Managing Dynamic Routing Gateways (DRGs)](/Content/Network/Tasks/managingDRGs.htm).

You may optionally specify a *display name* for the attachment, otherwise a default is provided.
It does not have to be unique, and you can change it. Avoid entering confidential information.

For the purposes of access control, the DRG attachment is automatically placed into the same compartment
as the VCN. For more information about compartments and access control, see
[Overview of the IAM Service](/Content/Identity/Concepts/overview.htm).

*/
func (a *Client) CreateDrgAttachment(params *CreateDrgAttachmentParams) (*CreateDrgAttachmentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateDrgAttachmentParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateDrgAttachment",
		Method:             "POST",
		PathPattern:        "/drgAttachments",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateDrgAttachmentReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateDrgAttachmentOK), nil

}

/*
CreateIPSecConnection creates IP sec connection

Creates a new IPSec connection between the specified DRG and CPE. For more information, see
[Managing IPSec Connections](/Content/Network/Tasks/managingIPsec.htm).

In the request, you must include at least one static route to the CPE object (you're allowed a maximum
of 10). For example: 10.0.8.0/16.

For the purposes of access control, you must provide the OCID of the compartment where you want the
IPSec connection to reside. Notice that the IPSec connection doesn't have to be in the same compartment
as the DRG, CPE, or other Networking Service components. If you're not sure which compartment to
use, put the IPSec connection in the same compartment as the DRG. For more information about
compartments and access control, see
[Overview of the IAM Service](/Content/Identity/Concepts/overview.htm).
For information about OCIDs, see [Resource Identifiers](/Content/General/Concepts/identifiers.htm).

You may optionally specify a *display name* for the IPSec connection, otherwise a default is provided.
It does not have to be unique, and you can change it. Avoid entering confidential information.

After creating the IPSec connection, you need to configure your on-premise router
with tunnel-specific information returned by
[GetIPSecConnectionDeviceConfig](#/en/iaas/20160918/IPSecConnectionDeviceConfig/GetIPSecConnectionDeviceConfig).
For each tunnel, that operation gives you the IP address of Oracle's VPN headend and the shared secret
(i.e., the pre-shared key). For more information, see
[Configuring Your On-Premise Router](/Content/Network/Tasks/configuringCPE.htm).

To get the status of the tunnels (whether they're up or down), use
[GetIPSecConnectionDeviceStatus](#/en/iaas/20160918/IPSecConnectionDeviceStatus/GetIPSecConnectionDeviceStatus).

*/
func (a *Client) CreateIPSecConnection(params *CreateIPSecConnectionParams) (*CreateIPSecConnectionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateIPSecConnectionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateIPSecConnection",
		Method:             "POST",
		PathPattern:        "/ipsecConnections",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateIPSecConnectionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateIPSecConnectionOK), nil

}

/*
CreateInternetGateway creates internet gateway

Creates a new Internet Gateway for the specified VCN. For more information, see
[Managing Internet Gateways](/Content/Network/Tasks/managingIGs.htm).

For the purposes of access control, you must provide the OCID of the compartment where you want the Internet
Gateway to reside. Notice that the Internet Gateway doesn't have to be in the same compartment as the VCN or
other Networking Service components. If you're not sure which compartment to use, put the Internet
Gateway in the same compartment with the VCN. For more information about compartments and access control, see
[Overview of the IAM Service](/Content/Identity/Concepts/overview.htm). For information about OCIDs, see
[Resource Identifiers](/Content/General/Concepts/identifiers.htm).

You may optionally specify a *display name* for the Internet Gateway, otherwise a default is provided. It
does not have to be unique, and you can change it. Avoid entering confidential information.

For traffic to flow between a subnet and an Internet Gateway, you must create a route rule accordingly in
the subnet's route table (e.g., 0.0.0.0/0 > Internet Gateway). See
[UpdateRouteTable](#/en/iaas/20160918/RouteTable/UpdateRouteTable).

You must specify whether the Internet Gateway is enabled when you create it. If it's disabled, that means no
traffic will flow to/from the internet even if there's a route rule that enables that traffic. You can later
use [UpdateInternetGateway](#/en/iaas/20160918/InternetGateway/UpdateInternetGateway) to easily disable/enable
the gateway without changing the route rule.

*/
func (a *Client) CreateInternetGateway(params *CreateInternetGatewayParams) (*CreateInternetGatewayOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateInternetGatewayParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateInternetGateway",
		Method:             "POST",
		PathPattern:        "/internetGateways",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateInternetGatewayReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateInternetGatewayOK), nil

}

/*
CreatePrivateIP creates private Ip

Creates a secondary private IP for the specified VNIC.
For more information about secondary private IPs, see
[Managing IP Addresses](/Content/Network/Tasks/managingIPaddresses.htm).

*/
func (a *Client) CreatePrivateIP(params *CreatePrivateIPParams) (*CreatePrivateIPOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreatePrivateIPParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreatePrivateIp",
		Method:             "POST",
		PathPattern:        "/privateIps",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreatePrivateIPReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreatePrivateIPOK), nil

}

/*
CreateRouteTable creates route table

Creates a new route table for the specified VCN. In the request you must also include at least one route
rule for the new route table. For information on the number of rules you can have in a route table, see
[Service Limits](/Content/General/Concepts/servicelimits.htm). For general information about route
tables in your VCN, see [Managing Route Tables](/Content/Network/Tasks/managingroutetables.htm).

For the purposes of access control, you must provide the OCID of the compartment where you want the route
table to reside. Notice that the route table doesn't have to be in the same compartment as the VCN, subnets,
or other Networking Service components. If you're not sure which compartment to use, put the route
table in the same compartment as the VCN. For more information about compartments and access control, see
[Overview of the IAM Service](/Content/Identity/Concepts/overview.htm). For information about OCIDs, see
[Resource Identifiers](/Content/General/Concepts/identifiers.htm).

You may optionally specify a *display name* for the route table, otherwise a default is provided.
It does not have to be unique, and you can change it. Avoid entering confidential information.

*/
func (a *Client) CreateRouteTable(params *CreateRouteTableParams) (*CreateRouteTableOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRouteTableParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateRouteTable",
		Method:             "POST",
		PathPattern:        "/routeTables",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateRouteTableReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateRouteTableOK), nil

}

/*
CreateSecurityList creates security list

Creates a new security list for the specified VCN. For more information
about security lists, see [Security Lists](/Content/Network/Concepts/securitylists.htm).
For information on the number of rules you can have in a security list, see
[Service Limits](/Content/General/Concepts/servicelimits.htm).

For the purposes of access control, you must provide the OCID of the compartment where you want the security
list to reside. Notice that the security list doesn't have to be in the same compartment as the VCN, subnets,
or other Networking Service components. If you're not sure which compartment to use, put the security
list in the same compartment as the VCN. For more information about compartments and access control, see
[Overview of the IAM Service](/Content/Identity/Concepts/overview.htm). For information about OCIDs, see
[Resource Identifiers](/Content/General/Concepts/identifiers.htm).

You may optionally specify a *display name* for the security list, otherwise a default is provided.
It does not have to be unique, and you can change it. Avoid entering confidential information.

*/
func (a *Client) CreateSecurityList(params *CreateSecurityListParams) (*CreateSecurityListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateSecurityListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateSecurityList",
		Method:             "POST",
		PathPattern:        "/securityLists",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateSecurityListReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateSecurityListOK), nil

}

/*
CreateSubnet creates subnet

Creates a new subnet in the specified VCN. You can't change the size of the subnet after creation,
so it's important to think about the size of subnets you need before creating them.
For more information, see [Managing Subnets](/Content/Network/Tasks/managingsubnets.htm).
For information on the number of subnets you can have in a VCN, see
[Service Limits](/Content/General/Concepts/servicelimits.htm).

For the purposes of access control, you must provide the OCID of the compartment where you want the subnet
to reside. Notice that the subnet doesn't have to be in the same compartment as the VCN, route tables, or
other Networking Service components. If you're not sure which compartment to use, put the subnet in
the same compartment as the VCN. For more information about compartments and access control, see
[Overview of the IAM Service](/Content/Identity/Concepts/overview.htm). For information about OCIDs,
see [Resource Identifiers](/Content/General/Concepts/identifiers.htm).

You may optionally associate a route table with the subnet. If you don't, the subnet will use the
VCN's default route table. For more information about route tables, see
[Managing Route Tables](/Content/Network/Tasks/managingroutetables.htm).

You may optionally associate a security list with the subnet. If you don't, the subnet will use the
VCN's default security list. For more information about security lists, see
[Security Lists](/Content/Network/Concepts/securitylists.htm).

You may optionally associate a set of DHCP options with the subnet. If you don't, the subnet will use the
VCN's default set. For more information about DHCP options, see
[Managing DHCP Options](/Content/Network/Tasks/managingDHCP.htm).

You may optionally specify a *display name* for the subnet, otherwise a default is provided.
It does not have to be unique, and you can change it. Avoid entering confidential information.

You can also add a DNS label for the subnet, which is required if you want the Internet and
VCN Resolver to resolve hostnames for instances in the subnet. For more information, see
[DNS in Your Virtual Cloud Network](/Content/Network/Concepts/dns.htm).

*/
func (a *Client) CreateSubnet(params *CreateSubnetParams) (*CreateSubnetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateSubnetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateSubnet",
		Method:             "POST",
		PathPattern:        "/subnets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateSubnetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateSubnetOK), nil

}

/*
CreateVcn creates vcn

Creates a new Virtual Cloud Network (VCN). For more information, see
[Managing Virtual Cloud Networks (VCNs)](/Content/Network/Tasks/managingVCNs.htm).

For the VCN you must specify a single, contiguous IPv4 CIDR block. Oracle recommends using one of the
private IP address ranges specified in [RFC 1918](https://tools.ietf.org/html/rfc1918) (10.0.0.0/8,
172.16/12, and 192.168/16). Example: 172.16.0.0/16. The CIDR block can range from /16 to /30, and it
must not overlap with your on-premise network. You can't change the size of the VCN after creation.

For the purposes of access control, you must provide the OCID of the compartment where you want the VCN to
reside. Consult an Oracle Bare Metal Cloud Services administrator in your organization if you're not sure which
compartment to use. Notice that the VCN doesn't have to be in the same compartment as the subnets or other
Networking Service components. For more information about compartments and access control, see
[Overview of the IAM Service](/Content/Identity/Concepts/overview.htm). For information about OCIDs, see
[Resource Identifiers](/Content/General/Concepts/identifiers.htm).

You may optionally specify a *display name* for the VCN, otherwise a default is provided. It does not have to
be unique, and you can change it. Avoid entering confidential information.

You can also add a DNS label for the VCN, which is required if you want the instances to use the
Interent and VCN Resolver option for DNS in the VCN. For more information, see
[DNS in Your Virtual Cloud Network](/Content/Network/Concepts/dns.htm).

The VCN automatically comes with a default route table, default security list, and default set of DHCP options.
The OCID for each is returned in the response. You can't delete these default objects, but you can change their
contents (i.e., route rules, etc.)

The VCN and subnets you create are not accessible until you attach an Internet Gateway or set up an IPSec VPN
or FastConnect. For more information, see
[Overview of the Networking Service](/Content/Network/Concepts/overview.htm).

*/
func (a *Client) CreateVcn(params *CreateVcnParams) (*CreateVcnOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateVcnParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateVcn",
		Method:             "POST",
		PathPattern:        "/vcns",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateVcnReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateVcnOK), nil

}

/*
CreateVirtualCircuit creates virtual circuit

Creates a new virtual circuit to use with Oracle Bare Metal Cloud
Services FastConnect. For more information, see
[FastConnect Overview](/Content/Network/Concepts/fastconnect.htm).

For the purposes of access control, you must provide the OCID of the
compartment where you want the virtual circuit to reside. If you're
not sure which compartment to use, put the virtual circuit in the
same compartment with the DRG it's using. For more information about
compartments and access control, see
[Overview of the IAM Service](/Content/Identity/Concepts/overview.htm).
For information about OCIDs, see
[Resource Identifiers](/Content/General/Concepts/identifiers.htm).

You may optionally specify a *display name* for the virtual circuit.
It does not have to be unique, and you can change it. Avoid entering confidential information.

**Important:** When creating a virtual circuit, you specify a DRG for
the traffic to flow through. Make sure you attach the DRG to your
VCN and confirm the VCN's routing sends traffic to the DRG. Otherwise
traffic will not flow. For more information, see
[Managing Route Tables](/Content/Network/Tasks/managingroutetables.htm).

*/
func (a *Client) CreateVirtualCircuit(params *CreateVirtualCircuitParams) (*CreateVirtualCircuitOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateVirtualCircuitParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateVirtualCircuit",
		Method:             "POST",
		PathPattern:        "/virtualCircuits",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateVirtualCircuitReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateVirtualCircuitOK), nil

}

/*
DeleteCpe deletes cpe

Deletes the specified CPE object. The CPE must not be connected to a DRG. This is an asynchronous
operation; the CPE's `lifecycleState` will change to TERMINATING temporarily until the CPE is completely
removed.

*/
func (a *Client) DeleteCpe(params *DeleteCpeParams) (*DeleteCpeNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteCpeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteCpe",
		Method:             "DELETE",
		PathPattern:        "/cpes/{cpeId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteCpeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteCpeNoContent), nil

}

/*
DeleteCrossConnect deletes cross connect

Deletes the specified cross-connect. It must not be mapped to a
[VirtualCircuit](#/en/iaas/20160918/VirtualCircuit/).

*/
func (a *Client) DeleteCrossConnect(params *DeleteCrossConnectParams) (*DeleteCrossConnectNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteCrossConnectParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteCrossConnect",
		Method:             "DELETE",
		PathPattern:        "/crossConnects/{crossConnectId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteCrossConnectReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteCrossConnectNoContent), nil

}

/*
DeleteCrossConnectGroup deletes cross connect group

Deletes the specified cross-connect group. It must not contain any
cross-connects, and it cannot be mapped to a
[VirtualCircuit](#/en/iaas/20160918/VirtualCircuit/).

*/
func (a *Client) DeleteCrossConnectGroup(params *DeleteCrossConnectGroupParams) (*DeleteCrossConnectGroupNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteCrossConnectGroupParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteCrossConnectGroup",
		Method:             "DELETE",
		PathPattern:        "/crossConnectGroups/{crossConnectGroupId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteCrossConnectGroupReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteCrossConnectGroupNoContent), nil

}

/*
DeleteDhcpOptions deletes dhcp options

Deletes the specified set of DHCP options, but only if it's not associated with a subnet. You can't delete a
VCN's default set of DHCP options.

This is an asynchronous operation; the state of the set of options will switch to TERMINATING temporarily
until the set is completely removed.

*/
func (a *Client) DeleteDhcpOptions(params *DeleteDhcpOptionsParams) (*DeleteDhcpOptionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteDhcpOptionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteDhcpOptions",
		Method:             "DELETE",
		PathPattern:        "/dhcps/{dhcpId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteDhcpOptionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteDhcpOptionsOK), nil

}

/*
DeleteDrg deletes drg

Deletes the specified DRG. The DRG must not be attached to a VCN or be connected to your on-premise
network. Also, there must not be a route table that lists the DRG as a target. This is an asynchronous
operation; the DRG's `lifecycleState` will change to TERMINATING temporarily until the DRG is completely
removed.

*/
func (a *Client) DeleteDrg(params *DeleteDrgParams) (*DeleteDrgNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteDrgParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteDrg",
		Method:             "DELETE",
		PathPattern:        "/drgs/{drgId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteDrgReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteDrgNoContent), nil

}

/*
DeleteDrgAttachment deletes drg attachment

Detaches a DRG from a VCN by deleting the corresponding `DrgAttachment`. This is an asynchronous
operation; the attachment's `lifecycleState` will change to DETACHING temporarily until the attachment
is completely removed.

*/
func (a *Client) DeleteDrgAttachment(params *DeleteDrgAttachmentParams) (*DeleteDrgAttachmentNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteDrgAttachmentParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteDrgAttachment",
		Method:             "DELETE",
		PathPattern:        "/drgAttachments/{drgAttachmentId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteDrgAttachmentReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteDrgAttachmentNoContent), nil

}

/*
DeleteIPSecConnection deletes IP sec connection

Deletes the specified IPSec connection. If your goal is to disable the IPSec VPN between your VCN and
on-premise network, it's easiest to simply detach the DRG but keep all the IPSec VPN components intact.
If you were to delete all the components and then later need to create an IPSec VPN again, you would
need to configure your on-premise router again with the new information returned from
[CreateIPSecConnection](#/en/iaas/20160918/IPSecConnection/CreateIPSecConnection).

This is an asynchronous operation; the connection's `lifecycleState` will change to TERMINATING temporarily
until the connection is completely removed.

*/
func (a *Client) DeleteIPSecConnection(params *DeleteIPSecConnectionParams) (*DeleteIPSecConnectionNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteIPSecConnectionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteIPSecConnection",
		Method:             "DELETE",
		PathPattern:        "/ipsecConnections/{ipscId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteIPSecConnectionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteIPSecConnectionNoContent), nil

}

/*
DeleteInternetGateway deletes internet gateway

Deletes the specified Internet Gateway. The Internet Gateway does not have to be disabled, but
there must not be a route table that lists it as a target.

This is an asynchronous operation; the gateway's `lifecycleState` will change to TERMINATING temporarily
until the gateway is completely removed.

*/
func (a *Client) DeleteInternetGateway(params *DeleteInternetGatewayParams) (*DeleteInternetGatewayNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteInternetGatewayParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteInternetGateway",
		Method:             "DELETE",
		PathPattern:        "/internetGateways/{igId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteInternetGatewayReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteInternetGatewayNoContent), nil

}

/*
DeletePrivateIP deletes private Ip

Unassigns and deletes the specified private IP. You must
specify the object's OCID. The private IP address is returned to
the subnet's pool of available addresses.

This operation cannot be used with primary private IPs, which are
automatically unassigned and deleted when the VNIC is terminated.

*/
func (a *Client) DeletePrivateIP(params *DeletePrivateIPParams) (*DeletePrivateIPNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeletePrivateIPParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeletePrivateIp",
		Method:             "DELETE",
		PathPattern:        "/privateIps/{privateIpId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeletePrivateIPReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeletePrivateIPNoContent), nil

}

/*
DeleteRouteTable deletes route table

Deletes the specified route table, but only if it's not associated with a subnet. You can't delete a
VCN's default route table.

This is an asynchronous operation; the route table's `lifecycleState` will change to TERMINATING temporarily
until the route table is completely removed.

*/
func (a *Client) DeleteRouteTable(params *DeleteRouteTableParams) (*DeleteRouteTableNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRouteTableParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteRouteTable",
		Method:             "DELETE",
		PathPattern:        "/routeTables/{rtId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteRouteTableReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteRouteTableNoContent), nil

}

/*
DeleteSecurityList deletes security list

Deletes the specified security list, but only if it's not associated with a subnet. You can't delete
a VCN's default security list.

This is an asynchronous operation; the security list's `lifecycleState` will change to TERMINATING temporarily
until the security list is completely removed.

*/
func (a *Client) DeleteSecurityList(params *DeleteSecurityListParams) (*DeleteSecurityListNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteSecurityListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteSecurityList",
		Method:             "DELETE",
		PathPattern:        "/securityLists/{securityListId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteSecurityListReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteSecurityListNoContent), nil

}

/*
DeleteSubnet deletes subnet

Deletes the specified subnet, but only if there are no instances in the subnet. This is an asynchronous
operation; the subnet's `lifecycleState` will change to TERMINATING temporarily. If there are any
instances in the subnet, the state will instead change back to AVAILABLE.

*/
func (a *Client) DeleteSubnet(params *DeleteSubnetParams) (*DeleteSubnetNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteSubnetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteSubnet",
		Method:             "DELETE",
		PathPattern:        "/subnets/{subnetId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteSubnetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteSubnetNoContent), nil

}

/*
DeleteVcn deletes vcn

Deletes the specified VCN. The VCN must be empty and have no attached gateways. This is an asynchronous
operation; the VCN's `lifecycleState` will change to TERMINATING temporarily until the VCN is completely
removed.

*/
func (a *Client) DeleteVcn(params *DeleteVcnParams) (*DeleteVcnNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteVcnParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteVcn",
		Method:             "DELETE",
		PathPattern:        "/vcns/{vcnId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteVcnReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteVcnNoContent), nil

}

/*
DeleteVirtualCircuit deletes virtual circuit

Deletes the specified virtual circuit.

**Important:** If you're using FastConnect via a provider,
make sure to also terminate the connection with
the provider, or else the provider may continue to bill you.

*/
func (a *Client) DeleteVirtualCircuit(params *DeleteVirtualCircuitParams) (*DeleteVirtualCircuitNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteVirtualCircuitParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteVirtualCircuit",
		Method:             "DELETE",
		PathPattern:        "/virtualCircuits/{virtualCircuitId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteVirtualCircuitReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteVirtualCircuitNoContent), nil

}

/*
GetCpe gets cpe

Gets the specified CPE's information.
*/
func (a *Client) GetCpe(params *GetCpeParams) (*GetCpeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCpeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetCpe",
		Method:             "GET",
		PathPattern:        "/cpes/{cpeId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetCpeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetCpeOK), nil

}

/*
GetCrossConnect gets cross connect

Gets the specified cross-connect's information.
*/
func (a *Client) GetCrossConnect(params *GetCrossConnectParams) (*GetCrossConnectOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCrossConnectParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetCrossConnect",
		Method:             "GET",
		PathPattern:        "/crossConnects/{crossConnectId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetCrossConnectReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetCrossConnectOK), nil

}

/*
GetCrossConnectGroup gets cross connect groups

Gets the specified cross-connect group's information.
*/
func (a *Client) GetCrossConnectGroup(params *GetCrossConnectGroupParams) (*GetCrossConnectGroupOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCrossConnectGroupParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetCrossConnectGroup",
		Method:             "GET",
		PathPattern:        "/crossConnectGroups/{crossConnectGroupId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetCrossConnectGroupReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetCrossConnectGroupOK), nil

}

/*
GetCrossConnectLetterOfAuthority gets cross connect letter of authority

Gets the Letter of Authority for the specified cross-connect.
*/
func (a *Client) GetCrossConnectLetterOfAuthority(params *GetCrossConnectLetterOfAuthorityParams) (*GetCrossConnectLetterOfAuthorityOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCrossConnectLetterOfAuthorityParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetCrossConnectLetterOfAuthority",
		Method:             "GET",
		PathPattern:        "/crossConnects/{crossConnectId}/letterOfAuthority",
		ProducesMediaTypes: []string{"application/json", "text/html"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetCrossConnectLetterOfAuthorityReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetCrossConnectLetterOfAuthorityOK), nil

}

/*
GetCrossConnectStatus gets cross connect status

Gets the status of the specified cross-connect.

*/
func (a *Client) GetCrossConnectStatus(params *GetCrossConnectStatusParams) (*GetCrossConnectStatusOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCrossConnectStatusParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetCrossConnectStatus",
		Method:             "GET",
		PathPattern:        "/crossConnects/{crossConnectId}/status",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetCrossConnectStatusReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetCrossConnectStatusOK), nil

}

/*
GetDhcpOptions gets dhcp options

Gets the specified set of DHCP options.
*/
func (a *Client) GetDhcpOptions(params *GetDhcpOptionsParams) (*GetDhcpOptionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDhcpOptionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetDhcpOptions",
		Method:             "GET",
		PathPattern:        "/dhcps/{dhcpId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetDhcpOptionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetDhcpOptionsOK), nil

}

/*
GetDrg gets drg

Gets the specified DRG's information.
*/
func (a *Client) GetDrg(params *GetDrgParams) (*GetDrgOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDrgParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetDrg",
		Method:             "GET",
		PathPattern:        "/drgs/{drgId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetDrgReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetDrgOK), nil

}

/*
GetDrgAttachment gets drg attachment

Gets the information for the specified `DrgAttachment`.
*/
func (a *Client) GetDrgAttachment(params *GetDrgAttachmentParams) (*GetDrgAttachmentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDrgAttachmentParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetDrgAttachment",
		Method:             "GET",
		PathPattern:        "/drgAttachments/{drgAttachmentId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetDrgAttachmentReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetDrgAttachmentOK), nil

}

/*
GetIPSecConnection gets IP sec connection

Gets the specified IPSec connection's basic information, including the static routes for the
on-premise router. If you want the status of the connection (whether it's up or down), use
[GetIPSecConnectionDeviceStatus](#/en/iaas/20160918/IPSecConnectionDeviceStatus/GetIPSecConnectionDeviceStatus).

*/
func (a *Client) GetIPSecConnection(params *GetIPSecConnectionParams) (*GetIPSecConnectionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetIPSecConnectionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetIPSecConnection",
		Method:             "GET",
		PathPattern:        "/ipsecConnections/{ipscId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetIPSecConnectionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetIPSecConnectionOK), nil

}

/*
GetIPSecConnectionDeviceConfig gets IP sec connection device config

Gets the configuration information for the specified IPSec connection. For each tunnel, the
response includes the IP address of Oracle's VPN headend and the shared secret.

*/
func (a *Client) GetIPSecConnectionDeviceConfig(params *GetIPSecConnectionDeviceConfigParams) (*GetIPSecConnectionDeviceConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetIPSecConnectionDeviceConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetIPSecConnectionDeviceConfig",
		Method:             "GET",
		PathPattern:        "/ipsecConnections/{ipscId}/deviceConfig",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetIPSecConnectionDeviceConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetIPSecConnectionDeviceConfigOK), nil

}

/*
GetIPSecConnectionDeviceStatus gets IP sec connection device status

Gets the status of the specified IPSec connection (whether it's up or down).

*/
func (a *Client) GetIPSecConnectionDeviceStatus(params *GetIPSecConnectionDeviceStatusParams) (*GetIPSecConnectionDeviceStatusOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetIPSecConnectionDeviceStatusParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetIPSecConnectionDeviceStatus",
		Method:             "GET",
		PathPattern:        "/ipsecConnections/{ipscId}/deviceStatus",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetIPSecConnectionDeviceStatusReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetIPSecConnectionDeviceStatusOK), nil

}

/*
GetInternetGateway gets internet gateway

Gets the specified Internet Gateway's information.
*/
func (a *Client) GetInternetGateway(params *GetInternetGatewayParams) (*GetInternetGatewayOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetInternetGatewayParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetInternetGateway",
		Method:             "GET",
		PathPattern:        "/internetGateways/{igId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetInternetGatewayReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetInternetGatewayOK), nil

}

/*
GetPrivateIP gets private Ip

Gets the specified private IP. You must specify the object's OCID.
Alternatively, you can get the object by using
[ListPrivateIps](#/en/iaas/20160918/PrivateIp/ListPrivateIps)
with the private IP address (for example, 10.0.3.3) and subnet OCID.

*/
func (a *Client) GetPrivateIP(params *GetPrivateIPParams) (*GetPrivateIPOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPrivateIPParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetPrivateIp",
		Method:             "GET",
		PathPattern:        "/privateIps/{privateIpId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetPrivateIPReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetPrivateIPOK), nil

}

/*
GetRouteTable gets route table

Gets the specified route table's information.
*/
func (a *Client) GetRouteTable(params *GetRouteTableParams) (*GetRouteTableOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRouteTableParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRouteTable",
		Method:             "GET",
		PathPattern:        "/routeTables/{rtId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetRouteTableReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRouteTableOK), nil

}

/*
GetSecurityList gets security list

Gets the specified security list's information.
*/
func (a *Client) GetSecurityList(params *GetSecurityListParams) (*GetSecurityListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSecurityListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetSecurityList",
		Method:             "GET",
		PathPattern:        "/securityLists/{securityListId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetSecurityListReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSecurityListOK), nil

}

/*
GetSubnet gets subnet

Gets the specified subnet's information.
*/
func (a *Client) GetSubnet(params *GetSubnetParams) (*GetSubnetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSubnetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetSubnet",
		Method:             "GET",
		PathPattern:        "/subnets/{subnetId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetSubnetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSubnetOK), nil

}

/*
GetVcn gets vcn

Gets the specified VCN's information.
*/
func (a *Client) GetVcn(params *GetVcnParams) (*GetVcnOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetVcnParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetVcn",
		Method:             "GET",
		PathPattern:        "/vcns/{vcnId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetVcnReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetVcnOK), nil

}

/*
GetVirtualCircuit gets virtual circuit

Gets the specified virtual circuit's information.
*/
func (a *Client) GetVirtualCircuit(params *GetVirtualCircuitParams) (*GetVirtualCircuitOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetVirtualCircuitParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetVirtualCircuit",
		Method:             "GET",
		PathPattern:        "/virtualCircuits/{virtualCircuitId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetVirtualCircuitReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetVirtualCircuitOK), nil

}

/*
GetVnic gets vnic

Gets the information for the specified virtual network interface card (VNIC).
You can get the VNIC OCID from the
[ListVnicAttachments](#/en/iaas/20160918/VnicAttachment/ListVnicAttachments)
operation.

*/
func (a *Client) GetVnic(params *GetVnicParams) (*GetVnicOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetVnicParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetVnic",
		Method:             "GET",
		PathPattern:        "/vnics/{vnicId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetVnicReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetVnicOK), nil

}

/*
ListCpes lists cpes

Lists the Customer-Premises Equipment objects (CPEs) in the specified compartment.

*/
func (a *Client) ListCpes(params *ListCpesParams) (*ListCpesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListCpesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListCpes",
		Method:             "GET",
		PathPattern:        "/cpes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListCpesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListCpesOK), nil

}

/*
ListCrossConnectGroups lists cross connect groups

Lists the cross-connect groups in the specified compartment.

*/
func (a *Client) ListCrossConnectGroups(params *ListCrossConnectGroupsParams) (*ListCrossConnectGroupsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListCrossConnectGroupsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListCrossConnectGroups",
		Method:             "GET",
		PathPattern:        "/crossConnectGroups",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListCrossConnectGroupsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListCrossConnectGroupsOK), nil

}

/*
ListCrossConnectLocations lists cross connect locations

Lists the available FastConnect locations for cross-connect installation. You need
this information so you can specify your desired location when you create a cross-connect.

*/
func (a *Client) ListCrossConnectLocations(params *ListCrossConnectLocationsParams) (*ListCrossConnectLocationsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListCrossConnectLocationsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListCrossConnectLocations",
		Method:             "GET",
		PathPattern:        "/crossConnectLocations",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListCrossConnectLocationsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListCrossConnectLocationsOK), nil

}

/*
ListCrossConnects lists cross connects

Lists the cross-connects in the specified compartment. You can filter the list
by specifying the OCID of a cross-connect group.

*/
func (a *Client) ListCrossConnects(params *ListCrossConnectsParams) (*ListCrossConnectsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListCrossConnectsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListCrossConnects",
		Method:             "GET",
		PathPattern:        "/crossConnects",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListCrossConnectsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListCrossConnectsOK), nil

}

/*
ListCrossconnectPortSpeedShapes lists cross connect port speed shapes

Lists the available port speeds for cross-connects. You need this information
so you can specify your desired port speed (i.e., shape) when you create a
cross-connect.

*/
func (a *Client) ListCrossconnectPortSpeedShapes(params *ListCrossconnectPortSpeedShapesParams) (*ListCrossconnectPortSpeedShapesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListCrossconnectPortSpeedShapesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListCrossconnectPortSpeedShapes",
		Method:             "GET",
		PathPattern:        "/crossConnectPortSpeedShapes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListCrossconnectPortSpeedShapesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListCrossconnectPortSpeedShapesOK), nil

}

/*
ListDhcpOptions lists dhcp options

Lists the sets of DHCP options in the specified VCN and specified compartment.
The response includes the default set of options that automatically comes with each VCN,
plus any other sets you've created.

*/
func (a *Client) ListDhcpOptions(params *ListDhcpOptionsParams) (*ListDhcpOptionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListDhcpOptionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListDhcpOptions",
		Method:             "GET",
		PathPattern:        "/dhcps",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListDhcpOptionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListDhcpOptionsOK), nil

}

/*
ListDrgAttachments lists drg attachments

Lists the `DrgAttachment` objects for the specified compartment. You can filter the
results by VCN or DRG.

*/
func (a *Client) ListDrgAttachments(params *ListDrgAttachmentsParams) (*ListDrgAttachmentsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListDrgAttachmentsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListDrgAttachments",
		Method:             "GET",
		PathPattern:        "/drgAttachments",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListDrgAttachmentsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListDrgAttachmentsOK), nil

}

/*
ListDrgs lists drgs

Lists the DRGs in the specified compartment.

*/
func (a *Client) ListDrgs(params *ListDrgsParams) (*ListDrgsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListDrgsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListDrgs",
		Method:             "GET",
		PathPattern:        "/drgs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListDrgsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListDrgsOK), nil

}

/*
ListFastConnectProviderServices lists fast connect provider services

Lists the service offerings from supported providers. You need this
information so you can specify your desired provider and service
offering when you create a virtual circuit.

For the compartment ID, provide the OCID of your tenancy (the root compartment).

For more information, see [FastConnect Overview](/Content/Network/Concepts/fastconnect.htm).

*/
func (a *Client) ListFastConnectProviderServices(params *ListFastConnectProviderServicesParams) (*ListFastConnectProviderServicesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListFastConnectProviderServicesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListFastConnectProviderServices",
		Method:             "GET",
		PathPattern:        "/fastConnectProviderServices",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListFastConnectProviderServicesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListFastConnectProviderServicesOK), nil

}

/*
ListIPSecConnections lists IP sec connections

Lists the IPSec connections for the specified compartment. You can filter the
results by DRG or CPE.

*/
func (a *Client) ListIPSecConnections(params *ListIPSecConnectionsParams) (*ListIPSecConnectionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListIPSecConnectionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListIPSecConnections",
		Method:             "GET",
		PathPattern:        "/ipsecConnections",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListIPSecConnectionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListIPSecConnectionsOK), nil

}

/*
ListInternetGateways lists internet gateways

Lists the Internet Gateways in the specified VCN and the specified compartment.

*/
func (a *Client) ListInternetGateways(params *ListInternetGatewaysParams) (*ListInternetGatewaysOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListInternetGatewaysParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListInternetGateways",
		Method:             "GET",
		PathPattern:        "/internetGateways",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListInternetGatewaysReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListInternetGatewaysOK), nil

}

/*
ListPrivateIps lists private ips

Lists the [PrivateIp](#/en/iaas/20160918/PrivateIp/) objects based
on one of these filters:

  - Subnet OCID.
  - VNIC OCID.
  - Both private IP address and subnet OCID: This lets
  you get a `privateIP` object based on its private IP
  address (for example, 10.0.3.3) and not its OCID. For comparison,
  [GetPrivateIp](#/en/iaas/20160918/PrivateIp/GetPrivateIp)
  requires the OCID.

If you're listing all the private IPs associated with a given subnet
or VNIC, the response includes both primary and secondary private IPs.

*/
func (a *Client) ListPrivateIps(params *ListPrivateIpsParams) (*ListPrivateIpsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListPrivateIpsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListPrivateIps",
		Method:             "GET",
		PathPattern:        "/privateIps",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListPrivateIpsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListPrivateIpsOK), nil

}

/*
ListRouteTables lists route tables

Lists the route tables in the specified VCN and specified compartment. The response
includes the default route table that automatically comes with each VCN, plus any route tables
you've created.

*/
func (a *Client) ListRouteTables(params *ListRouteTablesParams) (*ListRouteTablesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListRouteTablesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListRouteTables",
		Method:             "GET",
		PathPattern:        "/routeTables",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListRouteTablesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListRouteTablesOK), nil

}

/*
ListSecurityLists lists security lists

Lists the security lists in the specified VCN and compartment.

*/
func (a *Client) ListSecurityLists(params *ListSecurityListsParams) (*ListSecurityListsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListSecurityListsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListSecurityLists",
		Method:             "GET",
		PathPattern:        "/securityLists",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListSecurityListsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListSecurityListsOK), nil

}

/*
ListSubnets lists subnets

Lists the subnets in the specified VCN and the specified compartment.

*/
func (a *Client) ListSubnets(params *ListSubnetsParams) (*ListSubnetsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListSubnetsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListSubnets",
		Method:             "GET",
		PathPattern:        "/subnets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListSubnetsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListSubnetsOK), nil

}

/*
ListVcns lists vcns

Lists the Virtual Cloud Networks (VCNs) in the specified compartment.

*/
func (a *Client) ListVcns(params *ListVcnsParams) (*ListVcnsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListVcnsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListVcns",
		Method:             "GET",
		PathPattern:        "/vcns",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListVcnsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListVcnsOK), nil

}

/*
ListVirtualCircuitBandwidthShapes lists virtual circuit bandwidth shapes

Lists the available bandwidth levels for virtual circuits. You need this
information so you can specify your desired bandwidth level (i.e., shape)
when you create a virtual circuit.

For the compartment ID, provide the OCID of your tenancy (the root compartment).

For more information about virtual circuits, see
[FastConnect Overview](/Content/Network/Concepts/fastconnect.htm).

*/
func (a *Client) ListVirtualCircuitBandwidthShapes(params *ListVirtualCircuitBandwidthShapesParams) (*ListVirtualCircuitBandwidthShapesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListVirtualCircuitBandwidthShapesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListVirtualCircuitBandwidthShapes",
		Method:             "GET",
		PathPattern:        "/virtualCircuitBandwidthShapes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListVirtualCircuitBandwidthShapesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListVirtualCircuitBandwidthShapesOK), nil

}

/*
ListVirtualCircuits lists virtual circuits

Lists the virtual circuits in the specified compartment.

*/
func (a *Client) ListVirtualCircuits(params *ListVirtualCircuitsParams) (*ListVirtualCircuitsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListVirtualCircuitsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListVirtualCircuits",
		Method:             "GET",
		PathPattern:        "/virtualCircuits",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListVirtualCircuitsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListVirtualCircuitsOK), nil

}

/*
UpdateCpe updates cpe

Updates the specified CPE's display name.
Avoid entering confidential information.

*/
func (a *Client) UpdateCpe(params *UpdateCpeParams) (*UpdateCpeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateCpeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateCpe",
		Method:             "PUT",
		PathPattern:        "/cpes/{cpeId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateCpeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateCpeOK), nil

}

/*
UpdateCrossConnect updates cross connect

Updates the specified cross-connect.
*/
func (a *Client) UpdateCrossConnect(params *UpdateCrossConnectParams) (*UpdateCrossConnectOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateCrossConnectParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateCrossConnect",
		Method:             "PUT",
		PathPattern:        "/crossConnects/{crossConnectId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateCrossConnectReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateCrossConnectOK), nil

}

/*
UpdateCrossConnectGroup updates cross connect group

Updates the specified cross-connect group's display name.
Avoid entering confidential information.

*/
func (a *Client) UpdateCrossConnectGroup(params *UpdateCrossConnectGroupParams) (*UpdateCrossConnectGroupOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateCrossConnectGroupParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateCrossConnectGroup",
		Method:             "PUT",
		PathPattern:        "/crossConnectGroups/{crossConnectGroupId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateCrossConnectGroupReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateCrossConnectGroupOK), nil

}

/*
UpdateDhcpOptions updates dhcp options

Updates the specified set of DHCP options. You can update the display name or the options
themselves. Avoid entering confidential information.

Note that the `options` object you provide replaces the entire existing set of options.

*/
func (a *Client) UpdateDhcpOptions(params *UpdateDhcpOptionsParams) (*UpdateDhcpOptionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateDhcpOptionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateDhcpOptions",
		Method:             "PUT",
		PathPattern:        "/dhcps/{dhcpId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateDhcpOptionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateDhcpOptionsOK), nil

}

/*
UpdateDrg updates drg

Updates the specified DRG's display name. Avoid entering confidential information.

*/
func (a *Client) UpdateDrg(params *UpdateDrgParams) (*UpdateDrgOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateDrgParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateDrg",
		Method:             "PUT",
		PathPattern:        "/drgs/{drgId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateDrgReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateDrgOK), nil

}

/*
UpdateDrgAttachment updates drg attachment

Updates the display name for the specified `DrgAttachment`.
Avoid entering confidential information.

*/
func (a *Client) UpdateDrgAttachment(params *UpdateDrgAttachmentParams) (*UpdateDrgAttachmentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateDrgAttachmentParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateDrgAttachment",
		Method:             "PUT",
		PathPattern:        "/drgAttachments/{drgAttachmentId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateDrgAttachmentReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateDrgAttachmentOK), nil

}

/*
UpdateIPSecConnection updates IP sec connection

Updates the display name for the specified IPSec connection.
Avoid entering confidential information.

*/
func (a *Client) UpdateIPSecConnection(params *UpdateIPSecConnectionParams) (*UpdateIPSecConnectionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateIPSecConnectionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateIPSecConnection",
		Method:             "PUT",
		PathPattern:        "/ipsecConnections/{ipscId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateIPSecConnectionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateIPSecConnectionOK), nil

}

/*
UpdateInternetGateway updates internet gateway

Updates the specified Internet Gateway. You can disable/enable it, or change its display name.
Avoid entering confidential information.

If the gateway is disabled, that means no traffic will flow to/from the internet even if there's
a route rule that enables that traffic.

*/
func (a *Client) UpdateInternetGateway(params *UpdateInternetGatewayParams) (*UpdateInternetGatewayOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateInternetGatewayParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateInternetGateway",
		Method:             "PUT",
		PathPattern:        "/internetGateways/{igId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateInternetGatewayReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateInternetGatewayOK), nil

}

/*
UpdatePrivateIP updates private Ip

Updates the specified private IP. You must specify the object's OCID.
Use this operation if you want to:

  - Move a secondary private IP to a different VNIC in the same subnet.
  - Change the display name for a secondary private IP.
  - Change the hostname for a secondary private IP.

This operation cannot be used with primary private IPs.
To update the hostname for the primary IP on a VNIC, use
[UpdateVnic](#/en/iaas/20160918/Vnic/UpdateVnic).

*/
func (a *Client) UpdatePrivateIP(params *UpdatePrivateIPParams) (*UpdatePrivateIPOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdatePrivateIPParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdatePrivateIp",
		Method:             "PUT",
		PathPattern:        "/privateIps/{privateIpId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdatePrivateIPReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdatePrivateIPOK), nil

}

/*
UpdateRouteTable updates route table

Updates the specified route table's display name or route rules.
Avoid entering confidential information.

Note that the `routeRules` object you provide replaces the entire existing set of rules.

*/
func (a *Client) UpdateRouteTable(params *UpdateRouteTableParams) (*UpdateRouteTableOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateRouteTableParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateRouteTable",
		Method:             "PUT",
		PathPattern:        "/routeTables/{rtId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateRouteTableReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateRouteTableOK), nil

}

/*
UpdateSecurityList updates security list

Updates the specified security list's display name or rules.
Avoid entering confidential information.

Note that the `egressSecurityRules` or `ingressSecurityRules` objects you provide replace the entire
existing objects.

*/
func (a *Client) UpdateSecurityList(params *UpdateSecurityListParams) (*UpdateSecurityListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateSecurityListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateSecurityList",
		Method:             "PUT",
		PathPattern:        "/securityLists/{securityListId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateSecurityListReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateSecurityListOK), nil

}

/*
UpdateSubnet updates subnet

Updates the specified subnet's display name. Avoid entering confidential information.

*/
func (a *Client) UpdateSubnet(params *UpdateSubnetParams) (*UpdateSubnetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateSubnetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateSubnet",
		Method:             "PUT",
		PathPattern:        "/subnets/{subnetId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateSubnetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateSubnetOK), nil

}

/*
UpdateVcn updates vcn

Updates the specified VCN's display name.
Avoid entering confidential information.

*/
func (a *Client) UpdateVcn(params *UpdateVcnParams) (*UpdateVcnOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateVcnParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateVcn",
		Method:             "PUT",
		PathPattern:        "/vcns/{vcnId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateVcnReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateVcnOK), nil

}

/*
UpdateVirtualCircuit updates virtual circuit

Updates the specified virtual circuit. This can be called by
either the customer who owns the virtual circuit, or the
provider (when provisioning or de-provisioning the virtual
circuit from their end). The documentation for
[UpdateVirtualCircuitDetails](#/en/iaas/20160918/requests/UpdateVirtualCircuitDetails)
indicates who can update each property of the virtual circuit.

**Important:** If the virtual circuit is working and in the
PROVISIONED state, updating any of the network-related properties
(such as the DRG being used, the BGP ASN, etc.) will cause the virtual
circuit's state to switch to PROVISIONING and the related BGP
session to go down. After Oracle re-provisions the virtual circuit,
its state will return to PROVISIONED. Make sure you confirm that
the associated BGP session is back up. For more information
about the various states and how to test connectivity, see
[FastConnect Overview](/Content/Network/Concepts/fastconnect.htm).

*/
func (a *Client) UpdateVirtualCircuit(params *UpdateVirtualCircuitParams) (*UpdateVirtualCircuitOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateVirtualCircuitParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateVirtualCircuit",
		Method:             "PUT",
		PathPattern:        "/virtualCircuits/{virtualCircuitId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateVirtualCircuitReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateVirtualCircuitOK), nil

}

/*
UpdateVnic updates vnic

Updates the specified VNIC.

*/
func (a *Client) UpdateVnic(params *UpdateVnicParams) (*UpdateVnicOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateVnicParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateVnic",
		Method:             "PUT",
		PathPattern:        "/vnics/{vnicId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateVnicReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateVnicOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
